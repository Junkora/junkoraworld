-- JunkWorld MMORPG Schema + Seed
-- How to use:
-- 1) Open Supabase project https://zkabbhbgzrkdwzshdbed.supabase.co
-- 2) Go to SQL Editor, paste this entire script, and run it once.
-- 3) It will create tables, RLS policies, and seed reference data.

BEGIN;

-- Helper trigger: maintain updated_at timestamps
CREATE OR REPLACE FUNCTION public.set_updated_at()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

-- Core profile for each user
CREATE TABLE IF NOT EXISTS public.profiles (
  user_id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username text UNIQUE,
  wallet_address text,
  cash bigint NOT NULL DEFAULT 0 CHECK (cash >= 0),
  junk bigint NOT NULL DEFAULT 0 CHECK (junk >= 0),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- Per-user world position/state (one row per user)
CREATE TABLE IF NOT EXISTS public.user_state (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid NOT NULL DEFAULT auth.uid() REFERENCES public.profiles(user_id) ON DELETE CASCADE,
  pos_x double precision NOT NULL DEFAULT 0,
  pos_y double precision NOT NULL DEFAULT 0,
  pos_z double precision NOT NULL DEFAULT 0,
  zone text,
  updated_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE (user_id)
);

-- Skills reference (read-only catalog)
CREATE TABLE IF NOT EXISTS public.skills (
  id smallint PRIMARY KEY,
  slug text NOT NULL UNIQUE,
  name text NOT NULL
);

-- Per-user skill progression
CREATE TABLE IF NOT EXISTS public.user_skills (
  user_id uuid NOT NULL DEFAULT auth.uid() REFERENCES public.profiles(user_id) ON DELETE CASCADE,
  skill_id smallint NOT NULL REFERENCES public.skills(id) ON DELETE CASCADE,
  level int NOT NULL DEFAULT 1 CHECK (level >= 1),
  xp bigint NOT NULL DEFAULT 0 CHECK (xp >= 0),
  PRIMARY KEY (user_id, skill_id)
);

-- Items reference (optional catalog for inventory integrity)
CREATE TABLE IF NOT EXISTS public.items (
  id bigserial PRIMARY KEY,
  slug text NOT NULL UNIQUE,
  name text NOT NULL,
  rarity text,
  stackable boolean NOT NULL DEFAULT true
);

-- Per-user inventory (one row per item per user)
CREATE TABLE IF NOT EXISTS public.user_inventory (
  user_id uuid NOT NULL DEFAULT auth.uid() REFERENCES public.profiles(user_id) ON DELETE CASCADE,
  item_id bigint NOT NULL REFERENCES public.items(id) ON DELETE CASCADE,
  quantity bigint NOT NULL DEFAULT 0 CHECK (quantity >= 0),
  PRIMARY KEY (user_id, item_id)
);

-- Save slots (JSON blobs for arbitrary game state snapshots)
CREATE TABLE IF NOT EXISTS public.user_saves (
  user_id uuid NOT NULL DEFAULT auth.uid() REFERENCES public.profiles(user_id) ON DELETE CASCADE,
  slot smallint NOT NULL CHECK (slot BETWEEN 1 AND 10),
  data jsonb NOT NULL DEFAULT '{}'::jsonb,
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (user_id, slot)
);

-- updated_at triggers
DROP TRIGGER IF EXISTS set_updated_at_profiles ON public.profiles;
CREATE TRIGGER set_updated_at_profiles
BEFORE UPDATE ON public.profiles
FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

DROP TRIGGER IF EXISTS set_updated_at_user_state ON public.user_state;
CREATE TRIGGER set_updated_at_user_state
BEFORE UPDATE ON public.user_state
FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

DROP TRIGGER IF EXISTS set_updated_at_user_saves ON public.user_saves;
CREATE TRIGGER set_updated_at_user_saves
BEFORE UPDATE ON public.user_saves
FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

-- Useful indexes
CREATE INDEX IF NOT EXISTS idx_user_state_user_id ON public.user_state(user_id);
CREATE INDEX IF NOT EXISTS idx_user_skills_user_id ON public.user_skills(user_id);
CREATE INDEX IF NOT EXISTS idx_user_inventory_user_id ON public.user_inventory(user_id);
CREATE INDEX IF NOT EXISTS idx_user_saves_user_id ON public.user_saves(user_id);

-- Enable RLS on per-user tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_state ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_skills ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_inventory ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_saves ENABLE ROW LEVEL SECURITY;

-- Profiles policies
DROP POLICY IF EXISTS "Profiles are viewable by owner" ON public.profiles;
CREATE POLICY "Profiles are viewable by owner"
  ON public.profiles FOR SELECT
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Profiles can be inserted by owner" ON public.profiles;
CREATE POLICY "Profiles can be inserted by owner"
  ON public.profiles FOR INSERT
  WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Profiles can be updated by owner" ON public.profiles;
CREATE POLICY "Profiles can be updated by owner"
  ON public.profiles FOR UPDATE
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Profiles can be deleted by owner" ON public.profiles;
CREATE POLICY "Profiles can be deleted by owner"
  ON public.profiles FOR DELETE
  USING (auth.uid() = user_id);

-- User state policies
DROP POLICY IF EXISTS "State viewable by owner" ON public.user_state;
CREATE POLICY "State viewable by owner"
  ON public.user_state FOR SELECT
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "State insert by owner" ON public.user_state;
CREATE POLICY "State insert by owner"
  ON public.user_state FOR INSERT
  WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "State update by owner" ON public.user_state;
CREATE POLICY "State update by owner"
  ON public.user_state FOR UPDATE
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "State delete by owner" ON public.user_state;
CREATE POLICY "State delete by owner"
  ON public.user_state FOR DELETE
  USING (auth.uid() = user_id);

-- User skills policies
DROP POLICY IF EXISTS "User skills viewable by owner" ON public.user_skills;
CREATE POLICY "User skills viewable by owner"
  ON public.user_skills FOR SELECT
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "User skills insert by owner" ON public.user_skills;
CREATE POLICY "User skills insert by owner"
  ON public.user_skills FOR INSERT
  WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "User skills update by owner" ON public.user_skills;
CREATE POLICY "User skills update by owner"
  ON public.user_skills FOR UPDATE
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "User skills delete by owner" ON public.user_skills;
CREATE POLICY "User skills delete by owner"
  ON public.user_skills FOR DELETE
  USING (auth.uid() = user_id);

-- User inventory policies
DROP POLICY IF EXISTS "Inventory viewable by owner" ON public.user_inventory;
CREATE POLICY "Inventory viewable by owner"
  ON public.user_inventory FOR SELECT
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Inventory insert by owner" ON public.user_inventory;
CREATE POLICY "Inventory insert by owner"
  ON public.user_inventory FOR INSERT
  WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Inventory update by owner" ON public.user_inventory;
CREATE POLICY "Inventory update by owner"
  ON public.user_inventory FOR UPDATE
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Inventory delete by owner" ON public.user_inventory;
CREATE POLICY "Inventory delete by owner"
  ON public.user_inventory FOR DELETE
  USING (auth.uid() = user_id);

-- User saves policies
DROP POLICY IF EXISTS "Saves viewable by owner" ON public.user_saves;
CREATE POLICY "Saves viewable by owner"
  ON public.user_saves FOR SELECT
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Saves insert by owner" ON public.user_saves;
CREATE POLICY "Saves insert by owner"
  ON public.user_saves FOR INSERT
  WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Saves update by owner" ON public.user_saves;
CREATE POLICY "Saves update by owner"
  ON public.user_saves FOR UPDATE
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Saves delete by owner" ON public.user_saves;
CREATE POLICY "Saves delete by owner"
  ON public.user_saves FOR DELETE
  USING (auth.uid() = user_id);

-- Allow reading of reference catalogs
GRANT SELECT ON TABLE public.skills TO anon, authenticated;
GRANT SELECT ON TABLE public.items TO anon, authenticated;

-- Seed skills catalog
INSERT INTO public.skills (id, slug, name) VALUES
  (1, 'mining', 'Mining'),
  (2, 'woodcutting', 'Woodcutting'),
  (3, 'foraging', 'Foraging'),
  (4, 'fishing', 'Fishing'),
  (5, 'combat', 'Combat'),
  (6, 'smithing', 'Smithing'),
  (7, 'crafting', 'Crafting'),
  (8, 'alchemy', 'Alchemy'),
  (9, 'cooking', 'Cooking')
ON CONFLICT (id) DO NOTHING;

-- Optional: Seed a few item references (edit as needed)
INSERT INTO public.items (slug, name, rarity, stackable) VALUES
  ('copper_ore', 'Copper Ore', 'common', true),
  ('iron_ore', 'Iron Ore', 'common', true),
  ('wood_log', 'Wood Log', 'common', true),
  ('wild_herb', 'Wild Herb', 'common', true),
  ('raw_fish', 'Raw Fish', 'common', true),
  ('health_potion', 'Health Potion', 'uncommon', true),
  ('diamond', 'Diamond', 'legendary', true)
ON CONFLICT (slug) DO NOTHING;

COMMIT;

-- Notes / Examples:
-- 1) Create profile (client-side with supabase-js v2):
--    await supabase.from('profiles').insert({ user_id: user.id, username, wallet_address });
-- 2) Update balances:
--    await supabase.from('profiles').update({ cash: 100, junk: 5 }).eq('user_id', user.id);
-- 3) Save coordinates:
--    await supabase.from('user_state').upsert({ user_id: user.id, pos_x, pos_y, pos_z, zone });
-- 4) Upsert a skill:
--    await supabase.from('user_skills').upsert({ user_id: user.id, skill_id: 1, level: 5, xp: 1200 });
-- 5) Add inventory:
--    const { data: item } = await supabase.from('items').select('id').eq('slug','copper_ore').single();
--    await supabase.from('user_inventory').upsert({ user_id: user.id, item_id: item.id, quantity: 10 });
-- 6) Save slot:
--    await supabase.from('user_saves').upsert({ user_id: user.id, slot: 1, data: { quest: 'intro', step: 2 } });
-- 7) Load all:
--    const [profile, state, skills, inv, saves] = await Promise.all([
--      supabase.from('profiles').select('*').eq('user_id', user.id).single(),
--      supabase.from('user_state').select('*').eq('user_id', user.id).single(),
--      supabase.from('user_skills').select('*').eq('user_id', user.id),
--      supabase.from('user_inventory').select('quantity, items(id, slug, name, rarity)').eq('user_id', user.id),
--      supabase.from('user_saves').select('*').eq('user_id', user.id)
--    ]);
